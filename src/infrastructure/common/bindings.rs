/* automatically generated by rust-bindgen */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub const ID_MAPPING_DIALOG: u32 = 101;
    pub const ID_MAPPINGS_DIALOG: u32 = 104;
    pub const ID_MAPPING_ROW_DIALOG: u32 = 106;
    pub const ID_MAPPING_ROWS_DIALOG: u32 = 108;
    pub const ID_MAIN_DIALOG: u32 = 111;
    pub const ID_ADD_MAPPING_BUTTON: u32 = 40000;
    pub const ID_MAIN_PANEL_VERSION_TEXT: u32 = 40000;
    pub const ID_MAPPING_ROW_REMOVE_BUTTON: u32 = 40000;
    pub const ID_TARGET_PICK_ACTION_BUTTON: u32 = 40000;
    pub const ID_FEEDBACK_DEVICE_COMBO_BOX: u32 = 40001;
    pub const ID_MAPPING_ROW_EDIT_BUTTON: u32 = 40001;
    pub const ID_SETTINGS_REVERSE_CHECK_BOX: u32 = 40001;
    pub const ID_IMPORT_BUTTON: u32 = 40002;
    pub const ID_MAPPING_ROW_DUPLICATE_BUTTON: u32 = 40002;
    pub const ID_SOURCE_CHANNEL_COMBO_BOX: u32 = 40002;
    pub const ID_LET_UNMATCHED_EVENTS_THROUGH_CHECK_BOX: u32 = 40003;
    pub const ID_MAPPING_ROW_LEARN_SOURCE_BUTTON: u32 = 40003;
    pub const ID_SOURCE_LEARN_BUTTON: u32 = 40003;
    pub const ID_LET_MATCHED_EVENTS_THROUGH_CHECK_BOX: u32 = 40004;
    pub const ID_SOURCE_TYPE_COMBO_BOX: u32 = 40004;
    pub const ID_UP_BUTTON: u32 = 40004;
    pub const ID_ALWAYS_AUTO_DETECT_MODE_CHECK_BOX: u32 = 40005;
    pub const ID_MAPPING_ROW_SOURCE_LABEL_TEXT: u32 = 40005;
    pub const ID_SOURCE_CHARACTER_LABEL_TEXT: u32 = 40005;
    pub const ID_EXPORT_BUTTON: u32 = 40006;
    pub const ID_MAPPING_ROW_TARGET_LABEL_TEXT: u32 = 40006;
    pub const ID_TARGET_TYPE_COMBO_BOX: u32 = 40006;
    pub const ID_FILTER_BY_SOURCE_BUTTON: u32 = 40007;
    pub const ID_MAPPING_ROW_GROUP_BOX: u32 = 40007;
    pub const ID_TARGET_FX_PARAMETER_COMBO_BOX: u32 = 40007;
    pub const ID_MAPPING_ROW_LEARN_TARGET_BUTTON: u32 = 40008;
    pub const ID_SEND_FEEDBACK_BUTTON: u32 = 40008;
    pub const ID_TARGET_TRACK_OR_COMMAND_COMBO_BOX: u32 = 40008;
    pub const ID_MAPPING_ROW_FEEDBACK_CHECK_BOX: u32 = 40009;
    pub const ID_SEND_FEEDBACK_ONLY_IF_ARMED_CHECK_BOX: u32 = 40009;
    pub const ID_SETTINGS_STEP_SIZE_LABEL_TEXT: u32 = 40009;
    pub const ID_FILTER_BY_TARGET_BUTTON: u32 = 40010;
    pub const ID_MAPPING_ROW_CONTROL_CHECK_BOX: u32 = 40010;
    pub const ID_SETTINGS_RESET_BUTTON: u32 = 40010;
    pub const ID_CLEAR_TARGET_FILTER_BUTTON: u32 = 40011;
    pub const ID_DOWN_BUTTON: u32 = 40011;
    pub const ID_SETTINGS_MODE_COMBO_BOX: u32 = 40011;
    pub const ID_CLEAR_SOURCE_FILTER_BUTTON: u32 = 40012;
    pub const ID_SETTINGS_MIN_TARGET_VALUE_EDIT_CONTROL: u32 = 40012;
    pub const ID_CONTROL_DEVICE_COMBO_BOX: u32 = 40013;
    pub const ID_SETTINGS_MIN_SOURCE_VALUE_EDIT_CONTROL: u32 = 40013;
    pub const ID_HEADER_SEARCH_EDIT_CONTROL: u32 = 40014;
    pub const ID_SETTINGS_MAX_TARGET_VALUE_EDIT_CONTROL: u32 = 40014;
    pub const ID_SETTINGS_MAX_SOURCE_VALUE_EDIT_CONTROL: u32 = 40015;
    pub const ID_TARGET_FX_FOCUS_CHECK_BOX: u32 = 40016;
    pub const ID_SETTINGS_ROTATE_CHECK_BOX: u32 = 40017;
    pub const ID_SETTINGS_MIN_SOURCE_VALUE_SLIDER_CONTROL: u32 = 40018;
    pub const ID_SETTINGS_MAX_SOURCE_VALUE_SLIDER_CONTROL: u32 = 40019;
    pub const ID_SETTINGS_MIN_TARGET_VALUE_SLIDER_CONTROL: u32 = 40020;
    pub const ID_SETTINGS_MAX_TARGET_VALUE_SLIDER_CONTROL: u32 = 40021;
    pub const ID_SETTINGS_MAX_STEP_SIZE_EDIT_CONTROL: u32 = 40022;
    pub const ID_SETTINGS_MAX_STEP_SIZE_SLIDER_CONTROL: u32 = 40023;
    pub const ID_SETTINGS_MIN_STEP_SIZE_SLIDER_CONTROL: u32 = 40024;
    pub const ID_SETTINGS_MIN_STEP_SIZE_EDIT_CONTROL: u32 = 40025;
    pub const ID_TARGET_TRACK_OR_CMD_LABEL_TEXT: u32 = 40026;
    pub const ID_TARGET_FX_PARAMETER_LABEL_TEXT: u32 = 40027;
    pub const ID_TARGET_FX_OR_SEND_LABEL_TEXT: u32 = 40028;
    pub const ID_SOURCE_NOTE_OR_CC_NUMBER_LABEL_TEXT: u32 = 40029;
    pub const ID_TARGET_FX_OR_SEND_COMBO_BOX: u32 = 40030;
    pub const ID_SETTINGS_SOURCE_LABEL_TEXT: u32 = 40031;
    pub const ID_SOURCE_RPN_CHECK_BOX: u32 = 40032;
    pub const ID_SETTINGS_MIN_SOURCE_LABEL_TEXT: u32 = 40033;
    pub const ID_SETTINGS_MIN_STEP_SIZE_LABEL_TEXT: u32 = 40034;
    pub const ID_SETTINGS_MAX_STEP_SIZE_LABEL_TEXT: u32 = 40035;
    pub const ID_SETTINGS_MAX_SOURCE_LABEL_TEXT: u32 = 40036;
    pub const ID_SETTINGS_MIN_STEP_SIZE_VALUE_TEXT: u32 = 40037;
    pub const ID_SETTINGS_MAX_TARGET_VALUE_TEXT: u32 = 40038;
    pub const ID_TARGET_INPUT_FX_CHECK_BOX: u32 = 40039;
    pub const ID_SETTINGS_MAX_STEP_SIZE_VALUE_TEXT: u32 = 40040;
    pub const ID_SETTINGS_MIN_TARGET_VALUE_TEXT: u32 = 40041;
    pub const ID_SETTINGS_MIN_TARGET_JUMP_SLIDER_CONTROL: u32 = 40042;
    pub const ID_SETTINGS_ROUND_TARGET_VALUE_CHECK_BOX: u32 = 40043;
    pub const ID_SETTINGS_MIN_TARGET_JUMP_EDIT_CONTROL: u32 = 40044;
    pub const ID_SETTINGS_MIN_TARGET_JUMP_VALUE_TEXT: u32 = 40045;
    pub const ID_TARGET_VALUE_SLIDER_CONTROL: u32 = 40046;
    pub const ID_TARGET_VALUE_EDIT_CONTROL: u32 = 40047;
    pub const ID_TARGET_VALUE_TEXT: u32 = 40048;
    pub const ID_SOURCE_NUMBER_EDIT_CONTROL: u32 = 40049;
    pub const ID_TARGET_OPEN_BUTTON: u32 = 40050;
    pub const ID_TARGET_LEARN_BUTTON: u32 = 40051;
    pub const ID_SOURCE_CHARACTER_COMBO_BOX: u32 = 40052;
    pub const ID_SOURCE_NUMBER_COMBO_BOX: u32 = 40053;
    pub const ID_SOURCE_14_BIT_CHECK_BOX: u32 = 40054;
    pub const ID_SETTINGS_MAX_TARGET_JUMP_EDIT_CONTROL: u32 = 40055;
    pub const ID_SETTINGS_MAX_TARGET_JUMP_LABEL_TEXT: u32 = 40056;
    pub const ID_SETTINGS_MAX_TARGET_JUMP_SLIDER_CONTROL: u32 = 40057;
    pub const ID_SETTINGS_MAX_TARGET_JUMP_VALUE_TEXT: u32 = 40058;
    pub const ID_TARGET_TRACK_SELECTED_CHECK_BOX: u32 = 40059;
    pub const ID_MODE_EEL_CONTROL_TRANSFORMATION_EDIT_CONTROL: u32 = 40060;
    pub const ID_MODE_EEL_FEEDBACK_TRANSFORMATION_LABEL: u32 = 40061;
    pub const ID_MODE_EEL_CONTROL_TRANSFORMATION_LABEL: u32 = 40062;
    pub const ID_MODE_EEL_FEEDBACK_TRANSFORMATION_EDIT_CONTROL: u32 = 40063;
    pub const ID_SETTINGS_TARGET_JUMP_LABEL_TEXT: u32 = 40064;
    pub const ID_SOURCE_CHANNEL_LABEL: u32 = 40065;
    pub const ID_SETTINGS_MIN_TARGET_JUMP_LABEL_TEXT: u32 = 40066;
    pub const ID_SETTINGS_SCALE_MODE_CHECK_BOX: u32 = 40067;
    pub const ID_MAPPING_CONTROL_ENABLED_CHECK_BOX: u32 = 40068;
    pub const ID_MAPPING_FEEDBACK_ENABLED_CHECK_BOX: u32 = 40069;
    pub const ID_MAPPING_FIND_IN_LIST_BUTTON: u32 = 40070;
    pub const ID_MAPPING_NAME_EDIT_CONTROL: u32 = 40071;
    pub const ID_SETTINGS_IGNORE_OUT_OF_RANGE_CHECK_BOX: u32 = 40072;
    pub const ID_SOURCE_MIDI_CLOCK_TRANSPORT_MESSAGE_TYPE_COMBOX_BOX: u32 = 40073;
    pub const ID_SOURCE_MIDI_MESSAGE_TYPE_LABEL_TEXT: u32 = 40074;
    pub const ID_OK: u32 = 40075;
    pub const ID_TARGET_ACTION_LABEL_TEXT: u32 = 40076;
    pub const ID_CMD: u32 = 236;
    pub const ID_PSRESTARTWINDOWS: u32 = 2;
    pub const ID_PSREBOOTSYSTEM: u32 = 3;
    pub const ID_DEFAULTINST: i32 = -2;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub type INT_PTR = ::std::os::raw::c_longlong;
    pub type EEL_F = f64;
    extern "C" {
        pub fn NSEEL_HOSTSTUB_EnterMutex();
    }
    extern "C" {
        pub fn NSEEL_HOSTSTUB_LeaveMutex();
    }
    extern "C" {
        pub fn NSEEL_init() -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn NSEEL_quit();
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct functionType {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct eel_function_table {
        pub list: *mut root::functionType,
        pub list_size: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_eel_function_table() {
        assert_eq!(
            ::std::mem::size_of::<eel_function_table>(),
            16usize,
            concat!("Size of: ", stringify!(eel_function_table))
        );
        assert_eq!(
            ::std::mem::align_of::<eel_function_table>(),
            8usize,
            concat!("Alignment of ", stringify!(eel_function_table))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<eel_function_table>())).list as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(eel_function_table),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<eel_function_table>())).list_size as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(eel_function_table),
                "::",
                stringify!(list_size)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _compileContext {
        _unused: [u8; 0],
    }
    pub type NSEEL_PPPROC = ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            data_size: ::std::os::raw::c_int,
            userfunc_data: *mut root::_compileContext,
        ) -> *mut ::std::os::raw::c_void,
    >;
    extern "C" {
        pub fn NSEEL_addfunctionex2(
            name: *const ::std::os::raw::c_char,
            nparms: ::std::os::raw::c_int,
            code_startaddr: *mut ::std::os::raw::c_char,
            code_len: ::std::os::raw::c_int,
            pproc: root::NSEEL_PPPROC,
            fptr: *mut ::std::os::raw::c_void,
            fptr2: *mut ::std::os::raw::c_void,
            destination: *mut root::eel_function_table,
        );
    }
    extern "C" {
        pub fn NSEEL_addfunc_ret_type(
            name: *const ::std::os::raw::c_char,
            np: ::std::os::raw::c_int,
            ret_type: ::std::os::raw::c_int,
            pproc: root::NSEEL_PPPROC,
            fptr: *mut ::std::os::raw::c_void,
            destination: *mut root::eel_function_table,
        );
    }
    extern "C" {
        pub fn NSEEL_addfunc_varparm_ex(
            name: *const ::std::os::raw::c_char,
            min_np: ::std::os::raw::c_int,
            want_exact: ::std::os::raw::c_int,
            pproc: root::NSEEL_PPPROC,
            fptr: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: root::INT_PTR,
                    arg3: *mut *mut root::EEL_F,
                ) -> root::EEL_F,
            >,
            destination: *mut root::eel_function_table,
        );
    }
    extern "C" {
        pub fn NSEEL_getstats() -> *mut ::std::os::raw::c_int;
    }
    pub type NSEEL_VMCTX = *mut ::std::os::raw::c_void;
    pub type NSEEL_CODEHANDLE = *mut ::std::os::raw::c_void;
    extern "C" {
        pub fn NSEEL_VM_alloc() -> root::NSEEL_VMCTX;
    }
    extern "C" {
        pub fn NSEEL_VM_free(ctx: root::NSEEL_VMCTX);
    }
    extern "C" {
        pub fn NSEEL_VM_SetFunctionTable(
            arg1: root::NSEEL_VMCTX,
            tab: *mut root::eel_function_table,
        );
    }
    extern "C" {
        pub fn NSEEL_VM_SetFunctionValidator(
            arg1: root::NSEEL_VMCTX,
            validateFunc: ::std::option::Option<
                unsafe extern "C" fn(
                    fn_name: *const ::std::os::raw::c_char,
                    user: *mut ::std::os::raw::c_void,
                ) -> *const ::std::os::raw::c_char,
            >,
            user: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        pub fn NSEEL_VM_remove_unused_vars(_ctx: root::NSEEL_VMCTX);
    }
    extern "C" {
        pub fn NSEEL_VM_clear_var_refcnts(_ctx: root::NSEEL_VMCTX);
    }
    extern "C" {
        pub fn NSEEL_VM_remove_all_nonreg_vars(_ctx: root::NSEEL_VMCTX);
    }
    extern "C" {
        pub fn NSEEL_VM_enumallvars(
            ctx: root::NSEEL_VMCTX,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    name: *const ::std::os::raw::c_char,
                    val: *mut root::EEL_F,
                    ctx: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
            userctx: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        pub fn NSEEL_VM_regvar(
            ctx: root::NSEEL_VMCTX,
            name: *const ::std::os::raw::c_char,
        ) -> *mut root::EEL_F;
    }
    extern "C" {
        pub fn NSEEL_VM_getvar(
            ctx: root::NSEEL_VMCTX,
            name: *const ::std::os::raw::c_char,
        ) -> *mut root::EEL_F;
    }
    extern "C" {
        pub fn NSEEL_VM_get_var_refcnt(
            _ctx: root::NSEEL_VMCTX,
            name: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn NSEEL_VM_set_var_resolver(
            ctx: root::NSEEL_VMCTX,
            res: ::std::option::Option<
                unsafe extern "C" fn(
                    userctx: *mut ::std::os::raw::c_void,
                    name: *const ::std::os::raw::c_char,
                ) -> *mut root::EEL_F,
            >,
            userctx: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        pub fn NSEEL_VM_freeRAM(ctx: root::NSEEL_VMCTX);
    }
    extern "C" {
        pub fn NSEEL_VM_freeRAMIfCodeRequested(arg1: root::NSEEL_VMCTX);
    }
    extern "C" {
        pub fn NSEEL_VM_wantfreeRAM(ctx: root::NSEEL_VMCTX) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn NSEEL_VM_SetGRAM(ctx: root::NSEEL_VMCTX, gram: *mut *mut ::std::os::raw::c_void);
    }
    extern "C" {
        pub fn NSEEL_VM_FreeGRAM(ufd: *mut *mut ::std::os::raw::c_void);
    }
    extern "C" {
        pub fn NSEEL_VM_SetCustomFuncThis(
            ctx: root::NSEEL_VMCTX,
            thisptr: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        pub fn NSEEL_VM_getramptr(
            ctx: root::NSEEL_VMCTX,
            offs: ::std::os::raw::c_uint,
            validCount: *mut ::std::os::raw::c_int,
        ) -> *mut root::EEL_F;
    }
    extern "C" {
        pub fn NSEEL_VM_getramptr_noalloc(
            ctx: root::NSEEL_VMCTX,
            offs: ::std::os::raw::c_uint,
            validCount: *mut ::std::os::raw::c_int,
        ) -> *mut root::EEL_F;
    }
    extern "C" {
        pub fn NSEEL_VM_setramsize(
            ctx: root::NSEEL_VMCTX,
            maxent: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct eelStringSegmentRec {
        pub _next: *mut root::eelStringSegmentRec,
        pub str_start: *const ::std::os::raw::c_char,
        pub str_len: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_eelStringSegmentRec() {
        assert_eq!(
            ::std::mem::size_of::<eelStringSegmentRec>(),
            24usize,
            concat!("Size of: ", stringify!(eelStringSegmentRec))
        );
        assert_eq!(
            ::std::mem::align_of::<eelStringSegmentRec>(),
            8usize,
            concat!("Alignment of ", stringify!(eelStringSegmentRec))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<eelStringSegmentRec>()))._next as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(eelStringSegmentRec),
                "::",
                stringify!(_next)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<eelStringSegmentRec>())).str_start as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(eelStringSegmentRec),
                "::",
                stringify!(str_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<eelStringSegmentRec>())).str_len as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(eelStringSegmentRec),
                "::",
                stringify!(str_len)
            )
        );
    }
    extern "C" {
        pub fn NSEEL_VM_SetStringFunc(
            ctx: root::NSEEL_VMCTX,
            onString: ::std::option::Option<
                unsafe extern "C" fn(
                    caller_this: *mut ::std::os::raw::c_void,
                    list: *mut root::eelStringSegmentRec,
                ) -> root::EEL_F,
            >,
            onNamedString: ::std::option::Option<
                unsafe extern "C" fn(
                    caller_this: *mut ::std::os::raw::c_void,
                    name: *const ::std::os::raw::c_char,
                ) -> root::EEL_F,
            >,
        );
    }
    extern "C" {
        pub fn NSEEL_code_compile(
            ctx: root::NSEEL_VMCTX,
            code: *const ::std::os::raw::c_char,
            lineoffs: ::std::os::raw::c_int,
        ) -> root::NSEEL_CODEHANDLE;
    }
    extern "C" {
        pub fn NSEEL_code_compile_ex(
            ctx: root::NSEEL_VMCTX,
            code: *const ::std::os::raw::c_char,
            lineoffs: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> root::NSEEL_CODEHANDLE;
    }
    extern "C" {
        pub fn NSEEL_code_getcodeerror(ctx: root::NSEEL_VMCTX) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn NSEEL_code_geterror_flag(ctx: root::NSEEL_VMCTX) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn NSEEL_code_execute(code: root::NSEEL_CODEHANDLE);
    }
    extern "C" {
        pub fn NSEEL_code_free(code: root::NSEEL_CODEHANDLE);
    }
    extern "C" {
        pub fn NSEEL_code_getstats(code: root::NSEEL_CODEHANDLE) -> *mut ::std::os::raw::c_int;
    }
}
